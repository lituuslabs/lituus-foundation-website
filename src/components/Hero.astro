---
import RotatingCoil from './RotatingCoil.astro';
---

<style>
  /* Hero entrance animations */
  @keyframes fade-up {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  @keyframes line-expand {
    from {
      transform: scaleX(0);
      transform-origin: left;
    }
    to {
      transform: scaleX(1);
      transform-origin: left;
    }
  }

  .hero-animate {
    opacity: 0;
  }

  .hero-animate.animate {
    animation: fade-up 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  .hero-label.animate {
    animation-delay: 0.2s;
  }

  .hero-label-line {
    transform: scaleX(0);
  }

  .hero-label-line.animate {
    animation: line-expand 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    animation-delay: 0.1s;
  }

  .hero-title-1.animate {
    animation-delay: 0.4s;
  }

  .hero-title-2.animate {
    animation-delay: 0.55s;
  }

  .hero-title-3.animate {
    animation-delay: 0.7s;
  }

  .hero-description.animate {
    animation-delay: 0.9s;
  }

  .hero-cta.animate {
    animation-delay: 1.1s;
  }

  .hero-cta-secondary.animate {
    animation-delay: 1.25s;
  }

  .hero-scroll {
    opacity: 0;
  }

  .hero-scroll.animate {
    animation: fade-in 1s ease-out forwards;
    animation-delay: 1.6s;
  }

  .hero-coil {
    opacity: 0;
  }

  .hero-coil.animate {
    animation: fade-in 1.5s ease-out forwards;
    animation-delay: 0.3s;
  }

  /* Parallax layers - optimized for GPU compositing */
  .hero-coil,
  .hero-content,
  .hero-scroll {
    will-change: transform;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }

  /* Reduced Motion */
  @media (prefers-reduced-motion: reduce) {
    .hero-animate,
    .hero-label-line,
    .hero-scroll,
    .hero-coil {
      animation: none;
      opacity: 1;
      transform: none;
    }

    .hero-coil,
    .hero-content,
    .hero-scroll {
      will-change: auto;
      transform: none !important;
    }
  }
</style>

<header id="hero" class="relative min-h-screen flex items-center pt-20">
  <!-- Rotating Coil Overlay -->
  <div class="absolute inset-x-0 flex items-center md:items-center hero-coil">
    <div class="w-full max-w-4xl md:max-w-7xl mx-auto md:flex justify-end">
      <RotatingCoil className="w-[180vw] md:max-w-3xl -mr-40 aspect-square" />
    </div>
  </div>

  <div class="max-w-7xl mx-auto px-6 w-full relative z-10 grid grid-cols-1 md:grid-cols-12 gap-12 hero-content">
    <div class="md:col-span-9 flex flex-col justify-center">
      <!-- Label -->
      <div class="flex items-center gap-4 mb-8">
        <div class="w-12 h-px bg-lituus-pink hero-label-line"></div>
        <span class="text-xs tracking-[0.2em] text-white uppercase hero-animate hero-label">
          Lituus Foundation
        </span>
      </div>

      <h1 class="text-6xl md:text-8xl font-light text-white mb-8 leading-[0.95] tracking-tight text-glow">
        <span class="whitespace-nowrap hero-animate hero-title-1 block">The Frontier</span>
        <span class="block hero-animate hero-title-2">
            <span>of</span> <span class="font-serif italic opacity-80 text-lituus-pink">Decentralized</span></span>
        <span class="hero-animate hero-title-3 block">Truth</span>
      </h1>

      <p class="text-lg md:text-xl font-light text-slate-200 leading-relaxed max-w-xl mb-12 border-l border-lituus-pink/30 pl-6 hero-animate hero-description">
          On a mission to further Augur oracle experimentation
      </p>

      <div class="flex flex-col sm:flex-row items-start gap-6">
        <a href="#" class="px-8 py-3 bg-lituus-pink text-[#2c2c2c] rounded-sm font-medium text-sm tracking-widest hover:bg-[#e8c5d1] transition-colors uppercase hero-animate hero-cta">
          Read Manifesto
        </a>
        <!-- <a href="#" class="px-8 py-3 border border-white/30 text-white rounded-sm font-medium text-sm tracking-widest hover:bg-white hover:text-[#2c2c2c] transition-all uppercase backdrop-blur-sm hero-animate hero-cta-secondary">
          View Research
        </a> -->
      </div>
    </div>
  </div>

  <!-- Scroll Indicator -->
  <div class="absolute bottom-10 left-6 flex items-center gap-4 hero-scroll">
    <div class="h-16 w-px bg-linear-to-b from-transparent via-lituus-pink to-transparent"></div>
    <span class="text-[10px] uppercase tracking-widest text-slate-300 font-thin rotate-90 origin-left translate-y-2">
      Scroll
    </span>
  </div>
</header>

<script>
  function initHeroAnimations() {
    const hero = document.querySelector('header.relative.min-h-screen');
    if (!hero) return;

    // Skip if already animated (prevents flicker on scroll back)
    if (hero.hasAttribute('data-animated')) return;

    const animatedElements = hero.querySelectorAll('.hero-animate, .hero-label-line, .hero-scroll, .hero-coil');

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            // Mark as animated so we don't replay on scroll back
            hero.setAttribute('data-animated', 'true');

            // Trigger entrance animations once
            animatedElements.forEach((el) => {
              el.classList.add('animate');

              // After animation completes, clear animation so JS can control opacity
              el.addEventListener('animationend', () => {
                const htmlEl = el as HTMLElement;
                htmlEl.style.animation = 'none';
                htmlEl.style.opacity = '1';
                // Preserve final transform state for line-expand animation
                if (el.classList.contains('hero-label-line')) {
                  htmlEl.style.transform = 'scaleX(1)';
                }
              }, { once: true });
            });

            // Stop observing after first animation
            observer.disconnect();
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: '0px 0px -10% 0px',
      }
    );

    observer.observe(hero);
  }

  function initParallax() {
    const hero = document.querySelector('header#hero') as HTMLElement;
    if (!hero) return;

    const coil = hero.querySelector('.hero-coil') as HTMLElement;
    const content = hero.querySelector('.hero-content') as HTMLElement;
    const scrollIndicator = hero.querySelector('.hero-scroll') as HTMLElement;

    // Check for reduced motion preference
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    // Cache heroHeight
    let heroHeight = hero.offsetHeight;

    // Update on resize with debounce
    let resizeTimeout: number;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() => {
        heroHeight = hero.offsetHeight;
      }, 100);
    }, { passive: true });

    let isScrolling = false;

    function updateParallax() {
      if (!isScrolling) return;

      const scrollY = window.scrollY;

      // Early exit when off-screen
      if (scrollY >= heroHeight) {
        if (coil) {
          coil.style.transform = 'translate3d(0, 0, 0)';
          coil.style.opacity = '0';
        }
        if (content) {
          content.style.transform = 'translate3d(0, 0, 0)';
          content.style.opacity = '0';
        }
        if (scrollIndicator) {
          scrollIndicator.style.transform = 'translate3d(0, 0, 0)';
          scrollIndicator.style.opacity = '0';
        }
        isScrolling = false;
        return;
      }

      // Calculate scroll progress (0 to 1)
      const scrollProgress = scrollY / heroHeight;

      // Use integer pixel values to avoid sub-pixel rendering
      const coilY = Math.round(scrollY * 0.3);
      const contentY = Math.round(scrollY * 0.6);
      const scrollY_val = Math.round(scrollY * 0.5);

      // Calculate fade-out opacity (starts fading at 20% scroll, fully faded at 60%)
      const fadeStart = 0.2;
      const fadeEnd = 0.6;
      const opacity = Math.max(0, Math.min(1, 1 - (scrollProgress - fadeStart) / (fadeEnd - fadeStart)));

      // Scroll indicator fades faster (fully faded at 30%)
      const scrollIndicatorOpacity = Math.max(0, 1 - scrollProgress / 0.3);

      // Update transforms and opacity
      if (coil) {
        coil.style.transform = `translate3d(0, ${coilY}px, 0)`;
        coil.style.opacity = String(opacity);
      }
      if (content) {
        content.style.transform = `translate3d(0, ${contentY}px, 0)`;
        content.style.opacity = String(opacity);
      }
      if (scrollIndicator) {
        scrollIndicator.style.transform = `translate3d(0, ${scrollY_val}px, 0)`;
        scrollIndicator.style.opacity = String(scrollIndicatorOpacity);
      }

      // Continue loop while scrolling
      if (isScrolling) {
        requestAnimationFrame(updateParallax);
      }
    }

    function onScroll() {
      if (!isScrolling) {
        isScrolling = true;
        requestAnimationFrame(updateParallax);
      }
    }

    // Stop scrolling flag after scroll ends
    let scrollTimeout: number;
    function onScrollEnd() {
      clearTimeout(scrollTimeout);
      scrollTimeout = window.setTimeout(() => {
        isScrolling = false;
      }, 50);
    }

    // Initial call
    updateParallax();

    window.addEventListener('scroll', () => {
      onScroll();
      onScrollEnd();
    }, { passive: true });

    // Cleanup
    document.addEventListener('astro:before-swap', () => {
      window.removeEventListener('scroll', onScroll);
      clearTimeout(scrollTimeout);
    }, { once: true });
  }

  // Run on initial load
  initHeroAnimations();
  initParallax();

  // Re-run on Astro page transitions (View Transitions)
  document.addEventListener('astro:page-load', () => {
    initHeroAnimations();
    initParallax();
  });
</script>
